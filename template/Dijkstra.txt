//最短路径算法 Dijkstra
#include <vector>
#include <queue>

using namespace std;


class QueNode{
public:
	int node;
	int dist;
	QueNode(int _node, int _dist): node(_node), dist(_dist){}
	bool operator< (const QueNode & queNode) const{
		return dist > queNode.dist;
	}
};

class Dijkstra{
private:
	int st;
	int n;
	vector<int> dist;
	vector<vector<QueNode>> edges;
	priority_queue<QueNode> que;

	void clearQue(){
		while(!que.empty())	 que.pop();
	}

public:
	static const int INFINITE_DIST = 0X7FFFFFFF;
	Dijkstra(int _n, int _st){
		reset(_n, _st);
	}

	void reset(int _n, int _st){
		n = _n;
		st = _st;
		dist.resize(n);
		edges.resize(n);
		for(int i = 0; i < n; i++){
			dist[i] = INFINITE_DIST;
			edges[i].clear();
		}
		dist[st] = 0;
	}

	int runMinDist(int ed){
		clearQue();
		que.push(QueNode(st, 0));
		int top, u;
		while(!que.empty()){
			top = que.top().node;
			for(int i = 0; i < edges[top].size(); i++){
				u = edges[top][i].node;
				if(dist[u] > dist[top] + edges[top][i].dist){
					dist[u] = dist[top] + edges[top][i].dist;
					que.push(QueNode(u, dist[u]));
				}
			}
			que.pop();
		}
		/*
		for(int i = 0; i < n; i++){
			cout << "node=" << i << " ";
			cout << "edges [";
			for(int j = 0; j < edges[i].size(); j++){
				if(j > 0) cout << ",";
				cout << edges[i][j].node << "-" << edges[i][j].dist;
			}
			cout << "] dist = " << dist[i] << endl;
		}
		*/
		return dist[ed];
	}

	void addEdge(int from, int to, int len){
		edges[from].push_back(QueNode(to, len));
	}

	~Dijkstra(){
		dist.clear();
		clearQue();
	}
};
